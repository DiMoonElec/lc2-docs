---
hide:
  - toc
---
# Передача параметров функциям

Функции в языке LC могут принимать параметры двух видов: примитивные типы и ссылки.

## Функции без аргументов

Функции могут не принимать аргументы. В этом случае скобки остаются пустыми.

### Пример:

```cs
int getConstant()
{
  return 42;
}

void loop()
{
  int value = getConstant(); // value = 42
}
```

## Примитивные типы
Параметры примитивных типов (`sbyte`, `short`, `int`, `long`, `byte`, `ushort`, `uint`, `ulong`, `float`, `double`, `bool`) передаются по значению. Это означает, что при вызове функции создаётся локальная копия аргумента. Изменения в теле функции не влияют на оригинальные переменные.

### Пример
```cs
int add(int a, int b)
{
  return a + b;
}

void loop()
{
  int result = add(3, 5); // result = 8
}
```
В этом примере переменные `a` и `b` внутри `add` являются копиями значений, переданных из `loop()`.

## Передача по ссылке структур и массивов
Составные типы данных (массивы и структуры) передаются в функции по ссылке. Это означает, что функция получает доступ к оригинальному объекту в памяти. Все изменения, выполненные внутри функции, отражаются на переданном объекте.  

❗ Переменные типа "ссылка" напрямую создавать нельзя — они используются только в списке параметров функций.

### Пример с массивом

```cs
short[10] myArray;

void setValue(short[] a)
{
  a[2] = 42;
}

void loop()
{
  setValue(myArray);
  // myArray[2] теперь равен 42
}
```

### Пример со структурой

```cs
struct my_struct_t 
{
  int item1;
  bool[10] item2;
  short item3;
};

my_struct_t myStruct;

void update(my_struct_t s)
{
  s->item1 = 100;
  s->item2[5] = true;
}

void loop()
{
  update(myStruct);
  // myStruct->item1 == 100, myStruct->item2[5] == true
}
```