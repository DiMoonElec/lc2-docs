---
hide:
  - toc
---
# Приведение типов

## Приведение типов и типизация операций в LC
Язык LC использует строгую систему приведения типов, ориентированную на безопасность и предсказуемость поведения кода при работе с переменными. В LC разрешено приводить только **примитивные типы** (например, `byte`, `int`, `bool`). Приведение между структурами, массивами, указателями и т.п. не поддерживается.

### Явное приведение типов
Приведение типов по синтаксису похоже на C/C++:
```cs
int a = 10;
byte b = 20;

b = (byte)a;
a = (int)b;
```

---

## Автоматическое приведение типов
Автоматическое приведение типов в LC почти отсутствует. Это сделано намеренно — чтобы уменьшить количество трудноуловимых ошибок, связанных с неявным преобразованием типов и потерей данных. Автоматическое приведение допускается только в двух случаях:  

### Пример: присвоение литералов (констант)
```cs
byte a = 10;    // OK
int b = 300;    // OK
byte c = 300;   // Ошибка: 300 не помещается в byte
```
Если литерал может быть безопасно приведён к целевому типу без потери знака или переполнения — присваивание разрешается. Иначе — ошибка компиляции.

### Пример: передача литералов в функции
```cs
void foo(byte b) {
  //code
}

//...

foo(10);        // OK
foo(300);       // Ошибка: 300 выходит за пределы byte
```

---

## Типизация арифметических и побитовых операций
LC не использует неявное приведение типов в выражениях. Операции работают только между значениями одного и того же типа.  

### ✅ Допустимые примеры:
```cs
int a, b, c;
a = b + c;              // OK: все int

byte x, y, z;
x = y * z;              // OK: все byte
```

### ❌ Недопустимые примеры:
```cs
int a;
byte b, c;

a = b + c;              // Ошибка: результат byte + byte имеет тип byte, а не int
a = (int)b + (int)c;    // OK: явное приведение
```

Результат операции имеет тот же тип, что и её операнды. Это значит, что:  

- `byte` + `byte` → `byte`  
- `int` * `int` → `int`  
- и т. д.

В отличие от C, в LC нет автоматического расширения внутри выражений.

---

## Побитовые сдвиги: особые правила

Операции побитового сдвига (`<<`, `>>`) — единственное исключение из правила совпадения типов:
```cs
result = value << shift;
```  

- `value` — любого целочисленного типа
- `shift` — обязательно типа `byte`
- результат имеет тот же тип, что и `value`

### Пример (✅ OK):
```cs
int x = 1;
byte n = 3;
int y = x << n;         // OK
```

### Пример (❌ Ошибка):
```cs
int x = 1, n = 3;
int y = x << n;         // Ошибка: сдвиг `n` должен быть типа byte
```